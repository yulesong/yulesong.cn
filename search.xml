<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot项目在IntelliJ IDEA中实现热部署]]></title>
    <url>%2F2019%2F05%2F21%2Fidea-springboot%2F</url>
    <content type="text"><![CDATA[SpringBoot项目在IntelliJ IDEA中实现热部署方式一、 开启idea自动make功能1.在IDEA界面按CTRL+SHIFT＋Ａ-&gt;查找 make project automatically -&gt;选中如图： 2.CTRL+SHIFT+A–&gt;查找Registry–&gt;找到并勾选compiler.automake.allow.when.app.running如图： 3.重启IDEA 方式二、引入spring-boot-devtools依赖spring-boot-devtools是一个为开发者服务的一个模块，其中最重要的功能就是自动应用代码更改到最新的App上面去。 12原理是在发现代码有更改之后，重新启动应用，但是速度比手动停止后再启动更快。其深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类(第三方Jar包),另一个ClassLoader加载会更改的类，称为restart ClassLoader,这样在有代码更改的时候，原来的restartClassLoader被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间。 即devtools会自动监听classpath下的文件变动，并且会立即重启应用（发生在保存时机） 1.添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 2.在依赖中开启热部署 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt;//该配置必须 &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 接下来测试一下：1.修改类–&gt;保存：应用会重启2.修改配置文件–&gt;保存：应用会重启3.修改页面–&gt;保存：应用会重启，页面会刷新（原理是将spring.thymeleaf.cache设为false）至此你的IDEA就可以愉快的修改代码了，修改后可以及时的看到效果，无须重启和清除浏览器缓存]]></content>
      <categories>
        <category>SpringBoot项目在IntelliJ IDEA中实现热部署</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成swgger2错误解决（No enum constant org.springframework.web.bind.annotation.RequestMethod.Get）]]></title>
    <url>%2F2019%2F05%2F20%2Fswagger-bug%2F</url>
    <content type="text"><![CDATA[springboot在集成swagger2启动时遇到如下错误：123456java.lang.IllegalArgumentException: No enum constant org.springframework.web.bind.annotation.RequestMethod.Get at java.lang.Enum.valueOf(Enum.java:238) at org.springframework.web.bind.annotation.RequestMethod.valueOf(RequestMethod.java:35) at springfox.documentation.swagger.readers.operation.OperationHttpMethodReader.apply(OperationHttpMethodReader.java:49) at springfox.documentation.spring.web.plugins.DocumentationPluginsManager.operation(DocumentationPluginsManager.java:120) at springfox.documentation.spring.web.readers.operation.ApiOperationReader.read(ApiOperationReader.java:73) 12345678910111213141516171819202122232425262728293031at springfox.documentation.spring.web.scanners.CachingOperationReader$1.load(CachingOperationReader.java:50)at springfox.documentation.spring.web.scanners.CachingOperationReader$1.load(CachingOperationReader.java:48)at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3527)at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2319)at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2282)at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2197)at com.google.common.cache.LocalCache.get(LocalCache.java:3937)at com.google.common.cache.LocalCache.getOrLoad(LocalCache.java:3941)at com.google.common.cache.LocalCache$LocalLoadingCache.get(LocalCache.java:4824)at com.google.common.cache.LocalCache$LocalLoadingCache.getUnchecked(LocalCache.java:4830)at springfox.documentation.spring.web.scanners.CachingOperationReader.read(CachingOperationReader.java:57)at springfox.documentation.spring.web.scanners.ApiDescriptionReader.read(ApiDescriptionReader.java:66)at springfox.documentation.spring.web.scanners.ApiListingScanner.scan(ApiListingScanner.java:89)at springfox.documentation.spring.web.scanners.ApiDocumentationScanner.scan(ApiDocumentationScanner.java:71) at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.scanDocumentation(DocumentationPluginsBootstrapper.java:95)at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.start(DocumentationPluginsBootstrapper.java:154)at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:182)at org.springframework.context.support.DefaultLifecycleProcessor.access$200(DefaultLifecycleProcessor.java:53)at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:360)at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:158)at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:122)at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:879)at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:161)at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140)at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775)at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397)at org.springframework.boot.SpringApplication.run(SpringApplication.java:316)at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248)at com.wx.wlcx.WlcxApplication.main(WlcxApplication.java:14) 在controller 中用的是注解@GetMapping,在集成swagger2之前可以正常访问， 那问题就一定处在swagger2相关的code 中， 于是检查在code 中哪里用到了httpmethod, 发现了问题所在： 12345678910111213public enum RequestMethod &#123; GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE; private RequestMethod() &#123; &#125;&#125; 枚举类中method 方法都是大写， 而我的代码中将method 写成了： 12//api 具体描述@ApiOperation(value = "根据id查询公司具体信息", notes = "查询公司所有信息及送货地址", tags = &#123;"公司查询"&#125;, httpMethod = "Get") 这导致swagger 根据httpMethod 去获取enum 类的类型时匹配不到， 于是将httpMethod = “Get” 中的”Get” 改成”GET”即可。 1@ApiOperation(value = "根据id查询公司具体信息", notes = "查询公司所有信息及送货地址", tags = &#123;"公司查询"&#125;, httpMethod = "GET")]]></content>
      <categories>
        <category>springboot集成swgger2错误解决</category>
      </categories>
      <tags>
        <tag>swgger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swagger注解：@ApiOperation与@ApiImplicitParams使用]]></title>
    <url>%2F2019%2F05%2F20%2Fswagger-apiOperation-apiParam%2F</url>
    <content type="text"><![CDATA[@ApiOperation和@ApiImplicitParams@ApiOperation不是spring自带的注解是swagger里的com.wordnik.swagger.annotations.ApiOperation; @ApiImplicitParams：用在请求的方法上，包含一组参数说明 @ApiImplicitParams：用在请求的方法上，包含一组参数说明 @ApiImplicitParam：用在 @ApiImplicitParams 注解中，指定一个请求参数的配置信息 name：参数名 value：参数的汉字说明、解释 required：参数是否必须传 paramType：参数放在哪个地方 · header –&gt; 请求参数的获取：@RequestHeader · query –&gt; 请求参数的获取：@RequestParam · path（用于restful接口）–&gt; 请求参数的获取：@PathVariable · body（不常用） · form（不常用） dataType：参数类型，默认String，其它值dataType=”Integer” defaultValue：参数的默认值 12345@ApiImplicitParams(&#123; @ApiImplicitParam(name="mobile",value="手机号",required=true,paramType="form"), @ApiImplicitParam(name="password",value="密码",required=true,paramType="form"), @ApiImplicitParam(name="age",value="年龄",required=true,paramType="form",dataType="Integer")&#125;) 实体注解 @ApiModel和@ApiModelProperty123456789@ApiModel("用户")public class User &#123; @ApiModelProperty("用户ID") private long id; @ApiModelProperty("用户名") private String name; @ApiModelProperty("生日") private Date birth;&#125; 注解 作用域 说明 ApiModel 实体类名 描述实体 ApiModelProperty 实体属性 描述属性 实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。 Swagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目 实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档， 同时swagger-ui还可以测试spring restful风格的接口功能。]]></content>
      <categories>
        <category>Swagger注解说明</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解@PathVariable 与 @RequestParam]]></title>
    <url>%2F2019%2F05%2F17%2Fspring-pathVariable-requestParam%2F</url>
    <content type="text"><![CDATA[@PathVariable当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。示例代码： @Controller@RequestMapping(“/owners/{ownerId}”)public class RelativePathUriTemplateController { @RequestMapping(“/pets/{petId}”) public void findPet(@PathVariable(“ownerId”) String ownerId, @PathVariable(“petId”) String petId, Model model) { // implementation omitted }}上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。 @RequestParam当URL使用 someUrl?id=xxxxxx, 这时的id可通过 @RequestParam注解绑定它传过来的值到方法的参数上。 @RequestMapping(“/pets”) public void findPet(@RequestParam(“id”) String id) { // implementation omitted}]]></content>
      <categories>
        <category>Spring注解@PathVariable 与 @RequestParam</category>
      </categories>
      <tags>
        <tag>Spring注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10安装MySQL步骤]]></title>
    <url>%2F2019%2F05%2F16%2Fwin10-mysql%2F</url>
    <content type="text"><![CDATA[一、下载mysql1.在浏览器里打开mysql的官网(http://www.mysql.com/)2.进入页面顶部的”Downloads” 3.打开页面底部的“Community(GPL) Downloads” 4.在页面中间的位置找到我们windows上要用的下载页面“MySQL on Windows(Installer &amp; Tools)” 5.选择第一项”MySQL Installer” 6.页面底端找到下载入口“Windows (x86,32-bit), MSI Installer”，点击Download按钮开始下载，共381.4M 注意：MSI格式是指windows的安装程序，下载后直接双击就能进入安装向导的那种，区别于对文件进行解压的安装方式； 7.这个页面告诉询问你是否登录，告诉你登录之后有哪些好处，我们不登录，点击页面底部的“No thanks, just start my download.”按钮进入下载页面 8.开始下载，等待下载完成（由于直接下载速度太慢，之后我用迅雷下载完成的） 9.下载完成 二、安装mysql1.双击下载好的mysql安装文件“mysql-installer-community-5.7.14.0.msi”打开安装程序，打开后需要稍等一下 2.选择安装类型（根据个人需要） 3.我只需要安装mysql server，所以选择最后一项“Custom”，选择Custom之后左边的安装流程和右边的描述文字会改变，然后点击”Next”按钮继续 4.在这里我们需要从安装程序提供的可安装的产品（Products）中选择我们需要的mysql server 我们展开Available Products里的第一项“MySQL Servers”，依次展开其子结点，直到其终端结点，我的操作是64位的，所以选中“MySQL Server 5.7.14 - X64 然后点击绿色的向右箭头，将当前Product移动需要安装的列表，然后在右边展开“MySQL Server 5.7.14 - X64”项，取消“Development Components”的勾选（因为我们只需要安装mysql server），之后点击“Next”按钮进入下一步 5.点击“Execute”（执行）开始安装，安装过程中会显示安装的Progress（进度），等待安装完成后Status会显示Complete，mysql图标前会出现一个绿色的勾，然后点击“Next”按钮进入产品配置界面 6.点击“Next”按钮进入MySQL Server 的配置 Config Type选择“Development Machine”，选择此项将使用较小的内容来运行我们的mysql server，对应小型软件、学习是完全够用的。之后“Next” 在Root Account Password设置数据库root账号的密码，我填的是123456所以程序提醒我密码强度为弱，我们需要牢记这个密码，然后点击“Next” 这里可以设置mysql server的名称和是否开机启动，我把名称改为了“MySQLZzz1”，取消了开机启动，其它的没改，点击“Next” 点击“Next” 此界面将之前设置的配置内容应用到我们的mysql server，点击“Execute”，等待完成就可以了 配置完成，点击“Finish”完成配置环节 7.配置完成后将回到安装程序，我们点击“Next”继续 提示我们安装完成，点击“Finish” 三、测试是否安装成功我们使用MySQL管理软件（Navicat for MySQL）进行连接测试，确保mysql已经可以使用：这里我提供sqlNavicat怎么安装：就是傻瓜安装方法，安装好之后你们会遇到要求注册，直接解压我给你们的破解软件点击一下，在重新打开Navicat就ok拉： Navicat安装百度云地址：http://pan.baidu.com/s/1eSb7qpW 破解Navicat软件百度云地址：http://pan.baidu.com/s/1kVf0QQr 1.打开Navicat for MySQL 2.新建一个连接，填写连接信息：连接名称：用于区分不同的连接，自己命名即可主机名：localhost端口：3306用户名：root密码：123456（之前配置mysql的时候填写的密码） 3.点击“连接测试”按钮，弹出连接成功对话框即表示mysql server已开启 4.之后就是Navicat for MySQL软件的使用另：我们也可以在cmd里，再次输入“net start mysqlzzz1”，若提示“请求的服务已经启动。”表示mysql server已正常启动； 至此，mysql server在windows 10 64位上就安装完成了。 参考链接：https://www.jianshu.com/p/1aba608b21c5]]></content>
      <categories>
        <category>win10安装MySQL步骤</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo系列问题之我们换了电脑怎么办]]></title>
    <url>%2F2019%2F05%2F15%2Fchange-env%2F</url>
    <content type="text"><![CDATA[这个问题是我刚开始建站的时候就想到的问题，只是一直没时间做这些，最近有点时间了，处理一下这个问题 问题我们如果换了电脑怎么办？我们把hexo文件从一个电脑cope到另外一个电脑吗?答案肯定不是这样的，因为这里面有好多依赖包，好几万个文件呢，这样显然不合理 解决方案我们初步的解决方案是把我们的文件提交到git上，利用git来管理它，我是这样解决的：在现有的XXX.github.io项目上创建一个分支来管1.克隆gitHub上的XXX.github.io项目的文件到本地 1$ git clone https://github.com/yourname/xxx.github.io.git 2.删除文件夹里除了.git的其他所有文件3.把hexo项目文件下的所有文件全部复制过来4.里面应该有一个叫.gitignore的文件，如果没有就输入 touch .gitignore，创建一个5..gitignore文件里应该是这些内容 1234567.DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 6.创建一个叫hexo的分支并切换到这个分支上1$ git checkout -b hexo 7.提交复制过来的文件到暂存区1git add --all 8.提交1git commit -m "新建分支资源文件" 9.推送分支到github1git push --set-upstream origin hexo 到这一步我们就基本上搞定了，以后再跟新了博客就直接 git push就可以了，hexo的操作跟以前一样不变。 10.今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。克隆分支的操作1git clone -b hexo https://github.com/yourname/xxx.github.io.git 11.因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。12.这样做完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。 1原文链接：(https://blog.csdn.net/wxl1555/article/details/79293159)]]></content>
      <categories>
        <category>hexo系列问题之我们换了电脑怎么办</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO 基本命令使用]]></title>
    <url>%2F2018%2F06%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo基本命令</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
