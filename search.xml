<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Idea注册码激活]]></title>
    <url>%2F2019%2F06%2F27%2Fidea-activate%2F</url>
    <content type="text"><![CDATA[修改host文件，获取注册码激活IDEA 修改host文件打开路径C:\Windows\System32\drivers\etc，修改host文件，在末尾追加域名 0.0.0.0 account.jetbrains.com 及 0.0.0.0 www.jetbrains.com 输入激活码访问lanyus地址：http://idea.lanyus.com/（这里可不用访问，直接复制下面一行注册码）点击获得注册码，156ZS5PQ1RF-eyJsaWNlbnNlSWQiOiI1NlpTNVBRMVJGIiwibGljZW5zZWVOYW1lIjoi5q2j54mI5o6I5p2DIC4iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9XSwiaGFzaCI6IjEyMjkxNDk4LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-SYSsDcgL1WJmHnsiGaHUWbaZLPIe2oI3QiIneDtaIbh/SZOqu63G7RGudSjf3ssPb1zxroMti/bK9II1ugHz/nTjw31Uah7D0HqeaCO7Zc0q9BeHysiWmBZ+8bABs5vr25GgIa5pO7CJhL7RitXQbWpAajrMBAeZ2En3wCgNwT6D6hNmiMlhXsWgwkw2OKnyHZ2dl8yEL+oV5SW14t7bdjYGKQrYjSd4+2zc4FnaX88yLnGNO9B3U6G+BuM37pxS5MjHrkHqMTK8W3I66mIj6IB6dYXD5nvKKO1OZREBAr6LV0BqRYSbuJKFhZ8nd6YDG20GvW6leimv0rHVBFmA0w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== 具体步骤如下：]]></content>
      <categories>
        <category>Idea注册码激活</category>
      </categories>
      <tags>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java获取上周某一天日期1，2，3，4，5，6，7]]></title>
    <url>%2F2019%2F06%2F27%2Fjava-lastweekday%2F</url>
    <content type="text"><![CDATA[Java获取上周某一天日期1，2，3，4，5，6，7 123456789101112public static String getLastWeekDay(int weekDay)&#123; Calendar calendar = Calendar.getInstance(); int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1; if(dayOfWeek == 0)&#123; dayOfWeek = 7; &#125; int offset = weekDay - dayOfWeek; calendar.add(Calendar.DATE,offset-7); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); System.out.println(sdf.format(calendar.getTime()));&#125;]]></content>
      <categories>
        <category>Java获取上周某一天日期1，2，3，4，5，6，7</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题内添加相册功能]]></title>
    <url>%2F2019%2F06%2F24%2Fnext-photos%2F</url>
    <content type="text"><![CDATA[给博客添加一个相册页面，以展示自己拍摄的一些照片 (≖ᴗ≖)✧ _config.yml首先新建hexo new page photos相册页面，将会在source/下创建photos/index.md，在其中添加type: photos 之后在主题_config.yml文件中对应位置menu里添加Photos: /photos/ || image ，这样生成后就能在页面的对应页面选项中有该相册Tab。 json在博客根目录下新建uploadPhotos文件夹，里面将会存放照片以及相关js文件。 新建uploadPhotos/Images/文件夹，然后在其中存放需要在页面中展示的照片集（后续需将该文件夹上传至GitHub相册库，若没有对应库，可新建，并上传图片）。 新建uploadPhotos/tool.js文件，里面内容如下，主要功能是访问照片文件夹，获取每张照片的size和name，并生成对应的json文件： 命令：Git Bash中键入 node tool.js生成json注：若出现Error: Cannot find module ‘image-size’问题，请在Git Bash中键入对应命令npm install image-size进行安装。 1234567891011121314151617181920212223242526272829"use strict"; const fs = require("fs"); const sizeOf = require('image-size'); const path = "Images"; const output = "../themes/next/source/photos/photoslist.json"; var dimensions; fs.readdir(path, function (err, files) &#123; if (err) &#123; return; &#125; let arr = []; (function iterator(index) &#123; if (index == files.length) &#123; fs.writeFile(output, JSON.stringify(arr, null, "\t")); return; &#125; fs.stat(path + "/" + files[index], function (err, stats) &#123; if (err) &#123; return; &#125; if (stats.isFile()) &#123; dimensions = sizeOf(path + "/" + files[index]); console.log(dimensions.width, dimensions.height); arr.push(dimensions.width + '.' + dimensions.height + ' ' + files[index]); &#125; iterator(index + 1); &#125;) &#125;(0)); &#125;); json文件样例如下： 123456789[ "4032.3024 IMG_0391.JPG", "12500.3874 IMG_0404.JPG", "4032.3024 IMG_0416.JPG", "4032.3024 IMG_0424.JPG", "3024.4032 IMG_0427.JPG", "4032.3024 IMG_0429.JPG", "4032.3024 IMG_0430.JPG"] photo.js新建themes/next/source/photos/photo.js文件，其中photos文件夹是自己创建的。 photos.js内容如下，主要功能是访问json文件内容，遍历每行数据，并在页面对应位置上放置代码，展示图片（其中图片链接为自个GitHub相册库中图片的链接）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647photo =&#123; page: 1, offset: 20, init: function () &#123; var that = this; $.getJSON("/photos/photoslist.json", function (data) &#123; that.render(that.page, data); //that.scroll(data); &#125;); &#125;, render: function (page, data) &#123; var begin = (page - 1) * this.offset; var end = page * this.offset; if (begin &gt;= data.length) return; var html, imgNameWithPattern, imgName, imageSize, imageX, imageY, li = ""; for (var i = begin; i &lt; end &amp;&amp; i &lt; data.length; i++) &#123; imgNameWithPattern = data[i].split(' ')[1]; imgName = imgNameWithPattern.split('.')[0] imageSize = data[i].split(' ')[0]; imageX = imageSize.split('.')[0]; imageY = imageSize.split('.')[1]; li += '&lt;div class="card" style="width:330px"&gt;' + '&lt;div class="ImageInCard" style="height:'+ 330 * imageY / imageX + 'px"&gt;' + '&lt;a data-fancybox="gallery" href="https://github.com/asdfv1929/BlogPhotos/blob/master/Images/' + imgNameWithPattern + '?raw=true" data-caption="' + imgName + '"&gt;' + '&lt;img src="https://github.com/asdfv1929/BlogPhotos/blob/master/Images/' + imgNameWithPattern + '?raw=true"/&gt;' + '&lt;/a&gt;' + '&lt;/div&gt;' + // '&lt;div class="TextInCard"&gt;' + imgName + '&lt;/div&gt;' + '&lt;/div&gt;' &#125; $(".ImageGrid").append(li); $(".ImageGrid").lazyload(); this.minigrid(); &#125;, minigrid: function() &#123; var grid = new Minigrid(&#123; container: '.ImageGrid', item: '.card', gutter: 12 &#125;); grid.mount(); $(window).resize(function() &#123; grid.mount(); &#125;); &#125;&#125;photo.init(); photos.swig新建themes/next/layout/photos.swig文件，其内容模仿tag.swig中内容（直接复制粘贴），然后将其中的tag全部替换为photos。 photos.css.ImageGrid {width: 100%;max-width: 1040px;margin: 0 auto; text-align: center;}.card {overflow: hidden;transition: .3s ease-in-out; border-radius: 8px; background-color: #ddd;}.ImageInCard {}.ImageInCard img {padding: 0 0 0 0;}.TextInCard {line-height: 54px; background-color: #ffffff; font-size: 24px;} page.swig修改themes/next/layout/page.swig文件，添加下面代码中中间page.type === “photos”那两行。 123456789101112&#123;% block title %&#125;&#123;##&#125;&#123;% set page_title_suffix = ' | ' + config.title %&#125;&#123;##&#125;&#123;% if page.type === "categories" and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.category') + page_title_suffix &#125;&#125;&#123;##&#125;&#123;% elif page.type === "tags" and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.tag') + page_title_suffix &#125;&#125;&#123;##&#125;&#123;% elif page.type === "photos" and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.photos') + page_title_suffix &#125;&#125;&#123;##&#125;&#123;% else %&#125;&#123;# #&#125;&#123;&#123; page.title + page_title_suffix &#125;&#125;&#123;##&#125;&#123;% endif %&#125;&#123;##&#125;&#123;% endblock %&#125; 依旧是该文件中，添加page.type === “photos”那两行： 1234567891011121314&#123;% elif page.type === 'categories' %&#125; &lt;div class="category-all-page"&gt; &lt;div class="category-all-title"&gt; &#123;&#123; _p('counter.categories', site.categories.length) &#125;&#125; &lt;/div&gt; &lt;div class="category-all"&gt; &#123;&#123; list_categories() &#125;&#125; &lt;/div&gt; &lt;/div&gt;&#123;% elif page.type === 'photos' %&#125; &lt;div class="ImageGrid"&gt;&lt;/div&gt;&#123;% else %&#125; &#123;&#123; page.content &#125;&#125;&#123;% endif %&#125; _config.yml在主题配置文件_config.yml中相关部分，进行相关的配置（lazyload、fancybox）：首先确保_config.yml中Fancybox部分是否开启： 12# Fancyboxfancybox: true 之后亦在该文件_config.yml的末尾部分，找到 123vendors: # Internal path prefix. Please do not edit it. _internal: lib 在这个vendors的选项下面，有对应的fancybox、lazyload配置区域，填写相应的URL即可： 123456789101112131415vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js fancybox_css: https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: https://cdn.jsdelivr.net/npm/lazyload@2.0.0-beta.2/lazyload.js 之后在_layout.swig中相关信息配置： 123&lt;script type="text/javascript" src="https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js"&gt;&lt;/script&gt;&lt;link rel="stylesheet" href="/photos/photos.css"&gt;&lt;script type="text/javascript" src="/photos/photo.js"&gt;&lt;/script&gt; 重新生成访问，查看成果。 总结以上就是添加相册功能大概流程，因为步骤比较多，且是通过后期回忆步骤进行记录，所以可能存在些许问题，还请原谅，并请把出现的问题在本文下面的评论中点出，我会进行修改。 后续的实现： 将照片上传至GitHub相册库时，由于照片分辨率较高，其都达到了两三M以上，上传速度较慢，导致上传进度缓慢。后期想通过代码将照片进行压缩后再上传至相册库。 相册展示整个操作流程为：先上传照片到git库，再生成json文件，之后便是正常的clean、g、d，后期想把压缩、上传照片和生成json文件整合到一起。 目前的照片展示都是所有照片一整块放一起进行瀑布流显示，后期想将照片根据其旅游场景或类别、时间不同进行分类至对应文件夹，并根据类别或时间线显式展示出不同文件夹下的照片。 原文链接:(https://asdfv1929.github.io/2018/05/26/next-add-photos/#more)]]></content>
      <categories>
        <category>Hexo NexT主题内添加相册功能</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs模块——fs模块 WriteFile写入文件]]></title>
    <url>%2F2019%2F06%2F20%2Fnodejs-writefile%2F</url>
    <content type="text"><![CDATA[WriteFile写入文件使用fs.writeFile(filename,data,[options],callback)写入内容到文件。 参数说明： filename String 文件名 data String|buffer option Object encoding String |nulldefault=’utf-8’ mode Number default=438(aka 0666 in Octal) flag Stringdefault=’w’ callback Function 新建文件 readfile.js output.txt 代码：readfile.js12345678910111213141516171819var fs = require('fs'); // 引入fs模块 // 写入文件内容（如果文件不存在会创建一个文件）// 传递了追加参数 &#123; 'flag': 'a' &#125;fs.writeFile('./output.txt', 'HelloWorld', &#123; 'flag': 'a' &#125;, function(err) &#123; if (err) &#123; throw err; &#125; console.log('Hello.'); // 写入成功后读取测试 fs.readFile('./output.txt', 'utf-8', function(err, data) &#123; if (err) &#123; throw err; &#125; console.log(data); &#125;);&#125;); 输出打开cmd窗口，执行node readfile.js命令 查看结果]]></content>
      <categories>
        <category>nodejs模块——fs模块 WriteFile写入文件</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题中添加网页标题崩溃欺骗搞怪特效]]></title>
    <url>%2F2019%2F05%2F24%2Fnext-title%2F</url>
    <content type="text"><![CDATA[给网页title添加一些搞怪特效 crash_cheat.js在next\source\js\src文件夹下创建crash_cheat.js，添加代码： 1234567891011121314151617&lt;!--崩溃欺骗--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/TEP.ico"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/favicon.ico"); document.title = '(ฅ&gt;ω&lt;*ฅ) 噫又好了~' + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); 引用在next\layout_layout.swig文件中，添加引用（注：在swig末尾添加）： 12&lt;!--崩溃欺骗--&gt;&lt;script type="text/javascript" src="/js/src/crash_cheat.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>Hexo NexT主题中添加网页标题崩溃欺骗搞怪特效</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot项目在IntelliJ IDEA中实现热部署]]></title>
    <url>%2F2019%2F05%2F21%2Fidea-springboot%2F</url>
    <content type="text"><![CDATA[SpringBoot项目在IntelliJ IDEA中实现热部署方式一、 开启idea自动make功能1.在IDEA界面按CTRL+SHIFT＋Ａ-&gt;查找 make project automatically -&gt;选中如图： 2.CTRL+SHIFT+A–&gt;查找Registry–&gt;找到并勾选compiler.automake.allow.when.app.running如图： 3.重启IDEA 方式二、引入spring-boot-devtools依赖spring-boot-devtools是一个为开发者服务的一个模块，其中最重要的功能就是自动应用代码更改到最新的App上面去。 12原理是在发现代码有更改之后，重新启动应用，但是速度比手动停止后再启动更快。其深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类(第三方Jar包),另一个ClassLoader加载会更改的类，称为restart ClassLoader,这样在有代码更改的时候，原来的restartClassLoader被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间。 即devtools会自动监听classpath下的文件变动，并且会立即重启应用（发生在保存时机） 1.添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 2.在依赖中开启热部署 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt;//该配置必须 &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 接下来测试一下：1.修改类–&gt;保存：应用会重启2.修改配置文件–&gt;保存：应用会重启3.修改页面–&gt;保存：应用会重启，页面会刷新（原理是将spring.thymeleaf.cache设为false）至此你的IDEA就可以愉快的修改代码了，修改后可以及时的看到效果，无须重启和清除浏览器缓存]]></content>
      <categories>
        <category>SpringBoot项目在IntelliJ IDEA中实现热部署</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成swgger2错误解决（No enum constant org.springframework.web.bind.annotation.RequestMethod.Get）]]></title>
    <url>%2F2019%2F05%2F20%2Fswagger-bug%2F</url>
    <content type="text"><![CDATA[springboot在集成swagger2启动时遇到如下错误：123456java.lang.IllegalArgumentException: No enum constant org.springframework.web.bind.annotation.RequestMethod.Get at java.lang.Enum.valueOf(Enum.java:238) at org.springframework.web.bind.annotation.RequestMethod.valueOf(RequestMethod.java:35) at springfox.documentation.swagger.readers.operation.OperationHttpMethodReader.apply(OperationHttpMethodReader.java:49) at springfox.documentation.spring.web.plugins.DocumentationPluginsManager.operation(DocumentationPluginsManager.java:120) at springfox.documentation.spring.web.readers.operation.ApiOperationReader.read(ApiOperationReader.java:73) 12345678910111213141516171819202122232425262728293031at springfox.documentation.spring.web.scanners.CachingOperationReader$1.load(CachingOperationReader.java:50)at springfox.documentation.spring.web.scanners.CachingOperationReader$1.load(CachingOperationReader.java:48)at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3527)at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2319)at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2282)at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2197)at com.google.common.cache.LocalCache.get(LocalCache.java:3937)at com.google.common.cache.LocalCache.getOrLoad(LocalCache.java:3941)at com.google.common.cache.LocalCache$LocalLoadingCache.get(LocalCache.java:4824)at com.google.common.cache.LocalCache$LocalLoadingCache.getUnchecked(LocalCache.java:4830)at springfox.documentation.spring.web.scanners.CachingOperationReader.read(CachingOperationReader.java:57)at springfox.documentation.spring.web.scanners.ApiDescriptionReader.read(ApiDescriptionReader.java:66)at springfox.documentation.spring.web.scanners.ApiListingScanner.scan(ApiListingScanner.java:89)at springfox.documentation.spring.web.scanners.ApiDocumentationScanner.scan(ApiDocumentationScanner.java:71) at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.scanDocumentation(DocumentationPluginsBootstrapper.java:95)at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.start(DocumentationPluginsBootstrapper.java:154)at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:182)at org.springframework.context.support.DefaultLifecycleProcessor.access$200(DefaultLifecycleProcessor.java:53)at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:360)at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:158)at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:122)at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:879)at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:161)at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140)at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775)at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397)at org.springframework.boot.SpringApplication.run(SpringApplication.java:316)at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248)at com.wx.wlcx.WlcxApplication.main(WlcxApplication.java:14) 在controller 中用的是注解@GetMapping,在集成swagger2之前可以正常访问， 那问题就一定处在swagger2相关的code 中， 于是检查在code 中哪里用到了httpmethod, 发现了问题所在： 12345678910111213public enum RequestMethod &#123; GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE; private RequestMethod() &#123; &#125;&#125; 枚举类中method 方法都是大写， 而我的代码中将method 写成了： 12//api 具体描述@ApiOperation(value = "根据id查询公司具体信息", notes = "查询公司所有信息及送货地址", tags = &#123;"公司查询"&#125;, httpMethod = "Get") 这导致swagger 根据httpMethod 去获取enum 类的类型时匹配不到， 于是将httpMethod = “Get” 中的”Get” 改成”GET”即可。 1@ApiOperation(value = "根据id查询公司具体信息", notes = "查询公司所有信息及送货地址", tags = &#123;"公司查询"&#125;, httpMethod = "GET")]]></content>
      <categories>
        <category>springboot集成swgger2错误解决</category>
      </categories>
      <tags>
        <tag>swgger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swagger注解：@ApiOperation与@ApiImplicitParams使用]]></title>
    <url>%2F2019%2F05%2F20%2Fswagger-apiOperation-apiParam%2F</url>
    <content type="text"><![CDATA[@ApiOperation和@ApiImplicitParams@ApiOperation不是spring自带的注解是swagger里的com.wordnik.swagger.annotations.ApiOperation; @ApiImplicitParams：用在请求的方法上，包含一组参数说明 @ApiImplicitParam：用在 @ApiImplicitParams 注解中，指定一个请求参数的配置信息 name：参数名 value：参数的汉字说明、解释 required：参数是否必须传 paramType：参数放在哪个地方 · header --&gt; 请求参数的获取：@RequestHeader · query --&gt; 请求参数的获取：@RequestParam · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable · body（不常用） · form（不常用） dataType：参数类型，默认String，其它值dataType=&quot;Integer&quot; defaultValue：参数的默认值 12345@ApiImplicitParams(&#123; @ApiImplicitParam(name="mobile",value="手机号",required=true,paramType="form"), @ApiImplicitParam(name="password",value="密码",required=true,paramType="form"), @ApiImplicitParam(name="age",value="年龄",required=true,paramType="form",dataType="Integer")&#125;) 实体注解 @ApiModel和@ApiModelProperty123456789@ApiModel("用户")public class User &#123; @ApiModelProperty("用户ID") private long id; @ApiModelProperty("用户名") private String name; @ApiModelProperty("生日") private Date birth;&#125; 注解 作用域 说明 ApiModel 实体类名 描述实体 ApiModelProperty 实体属性 描述属性 实际项目中非常需要写文档，提高Java服务端和Web前端以及移动端的对接效率。 Swagger是当前最好用的Restful API文档生成的开源项目，通过swagger-spring项目 实现了与SpingMVC框架的无缝集成功能，方便生成spring restful风格的接口文档， 同时swagger-ui还可以测试spring restful风格的接口功能。]]></content>
      <categories>
        <category>Swagger注解说明</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解@PathVariable 与 @RequestParam]]></title>
    <url>%2F2019%2F05%2F17%2Fspring-pathVariable-requestParam%2F</url>
    <content type="text"><![CDATA[@PathVariable当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。示例代码： @Controller@RequestMapping(“/owners/{ownerId}”)public class RelativePathUriTemplateController { @RequestMapping(“/pets/{petId}”) public void findPet(@PathVariable(“ownerId”) String ownerId, @PathVariable(“petId”) String petId, Model model) { // implementation omitted }}上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。 @RequestParam当URL使用 someUrl?id=xxxxxx, 这时的id可通过 @RequestParam注解绑定它传过来的值到方法的参数上。 @RequestMapping(“/pets”) public void findPet(@RequestParam(“id”) String id) { // implementation omitted}]]></content>
      <categories>
        <category>Spring注解@PathVariable 与 @RequestParam</category>
      </categories>
      <tags>
        <tag>Spring注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10安装MySQL步骤]]></title>
    <url>%2F2019%2F05%2F16%2Fwin10-mysql%2F</url>
    <content type="text"><![CDATA[一、下载mysql1.在浏览器里打开mysql的官网(http://www.mysql.com/)2.进入页面顶部的”Downloads” 3.打开页面底部的“Community(GPL) Downloads” 4.在页面中间的位置找到我们windows上要用的下载页面“MySQL on Windows(Installer &amp; Tools)” 5.选择第一项”MySQL Installer” 6.页面底端找到下载入口“Windows (x86,32-bit), MSI Installer”，点击Download按钮开始下载，共381.4M 注意：MSI格式是指windows的安装程序，下载后直接双击就能进入安装向导的那种，区别于对文件进行解压的安装方式； 7.这个页面告诉询问你是否登录，告诉你登录之后有哪些好处，我们不登录，点击页面底部的“No thanks, just start my download.”按钮进入下载页面 8.开始下载，等待下载完成（由于直接下载速度太慢，之后我用迅雷下载完成的） 9.下载完成 二、安装mysql1.双击下载好的mysql安装文件“mysql-installer-community-5.7.14.0.msi”打开安装程序，打开后需要稍等一下 2.选择安装类型（根据个人需要） 3.我只需要安装mysql server，所以选择最后一项“Custom”，选择Custom之后左边的安装流程和右边的描述文字会改变，然后点击”Next”按钮继续 4.在这里我们需要从安装程序提供的可安装的产品（Products）中选择我们需要的mysql server 我们展开Available Products里的第一项“MySQL Servers”，依次展开其子结点，直到其终端结点，我的操作是64位的，所以选中“MySQL Server 5.7.14 - X64 然后点击绿色的向右箭头，将当前Product移动需要安装的列表，然后在右边展开“MySQL Server 5.7.14 - X64”项，取消“Development Components”的勾选（因为我们只需要安装mysql server），之后点击“Next”按钮进入下一步 5.点击“Execute”（执行）开始安装，安装过程中会显示安装的Progress（进度），等待安装完成后Status会显示Complete，mysql图标前会出现一个绿色的勾，然后点击“Next”按钮进入产品配置界面 6.点击“Next”按钮进入MySQL Server 的配置 Config Type选择“Development Machine”，选择此项将使用较小的内容来运行我们的mysql server，对应小型软件、学习是完全够用的。之后“Next” 在Root Account Password设置数据库root账号的密码，我填的是123456所以程序提醒我密码强度为弱，我们需要牢记这个密码，然后点击“Next” 这里可以设置mysql server的名称和是否开机启动，我把名称改为了“MySQLZzz1”，取消了开机启动，其它的没改，点击“Next” 点击“Next” 此界面将之前设置的配置内容应用到我们的mysql server，点击“Execute”，等待完成就可以了 配置完成，点击“Finish”完成配置环节 7.配置完成后将回到安装程序，我们点击“Next”继续 提示我们安装完成，点击“Finish” 三、测试是否安装成功我们使用MySQL管理软件（Navicat for MySQL）进行连接测试，确保mysql已经可以使用：这里我提供sqlNavicat怎么安装：就是傻瓜安装方法，安装好之后你们会遇到要求注册，直接解压我给你们的破解软件点击一下，在重新打开Navicat就ok拉： Navicat安装百度云地址：http://pan.baidu.com/s/1eSb7qpW 破解Navicat软件百度云地址：http://pan.baidu.com/s/1kVf0QQr 1.打开Navicat for MySQL 2.新建一个连接，填写连接信息：连接名称：用于区分不同的连接，自己命名即可主机名：localhost端口：3306用户名：root密码：123456（之前配置mysql的时候填写的密码） 3.点击“连接测试”按钮，弹出连接成功对话框即表示mysql server已开启 4.之后就是Navicat for MySQL软件的使用另：我们也可以在cmd里，再次输入“net start mysqlzzz1”，若提示“请求的服务已经启动。”表示mysql server已正常启动； 至此，mysql server在windows 10 64位上就安装完成了。 参考链接：https://www.jianshu.com/p/1aba608b21c5]]></content>
      <categories>
        <category>win10安装MySQL步骤</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo系列问题之我们换了电脑怎么办]]></title>
    <url>%2F2019%2F05%2F15%2Fchange-env%2F</url>
    <content type="text"><![CDATA[这个问题是我刚开始建站的时候就想到的问题，只是一直没时间做这些，最近有点时间了，处理一下这个问题 问题我们如果换了电脑怎么办？我们把hexo文件从一个电脑cope到另外一个电脑吗?答案肯定不是这样的，因为这里面有好多依赖包，好几万个文件呢，这样显然不合理 解决方案我们初步的解决方案是把我们的文件提交到git上，利用git来管理它，我是这样解决的：在现有的XXX.github.io项目上创建一个分支来管1.克隆gitHub上的XXX.github.io项目的文件到本地 1$ git clone https://github.com/yourname/xxx.github.io.git 2.删除文件夹里除了.git的其他所有文件3.把hexo项目文件下的所有文件全部复制过来4.里面应该有一个叫.gitignore的文件，如果没有就输入 touch .gitignore，创建一个5..gitignore文件里应该是这些内容 1234567.DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 6.创建一个叫hexo的分支并切换到这个分支上1$ git checkout -b hexo 7.提交复制过来的文件到暂存区1git add --all 8.提交1git commit -m "新建分支资源文件" 9.推送分支到github1git push --set-upstream origin hexo 到这一步我们就基本上搞定了，以后再跟新了博客就直接 git push就可以了，hexo的操作跟以前一样不变。 10.今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。克隆分支的操作1git clone -b hexo https://github.com/yourname/xxx.github.io.git 11.因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。12.这样做完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。 1原文链接：(https://blog.csdn.net/wxl1555/article/details/79293159)]]></content>
      <categories>
        <category>hexo系列问题之我们换了电脑怎么办</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO 基本命令使用]]></title>
    <url>%2F2018%2F06%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo基本命令</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
